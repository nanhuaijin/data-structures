# 数据结构与算法

## 一、时间复杂度

1.常数操作：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作。

> 比如加减乘除、比较、数组交换操作、位运算...

2.等差数列通项公式：an = a1 + (n-1)d

3.等差数列求和公式：Sn = na1 + n(n-1)d/2         Sn = n(a1+an)/2

4.**时间复杂度：**写出常数操作数量的表达式，只要最高阶项，不要低阶项，也不要最高阶项的系数，剩下的部分如果是f(N)，那么时间复杂度就是O(f(N))，并且按照最坏情况取值

> 比如 aN^2 + bN + c 取最高项 aN^2，去除系数N^2 时间复杂度O(n^2)

5.最高阶项排序：n^n  >  n^2 > nlogn > n > logn > c

6.评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

## 二、额外空间复杂度
## 三、排序算法
1.位运算
- 与 & ：都为1才为1
- 或 | ：有一个为1就为1
- 非 ~ ：取反
- 异或 ^ ：不同为1，相同为0，也叫做无进位相加
> 0 ^ N = N  N ^ N = 0
>
> 异或符合交换结合律 
>
> 使用异或交换两个数ab的值，前提是ab指向的内存地址是不同的，如果内存地址相同，ab就会变成0
- a & (a - 1) 如果a>0一直执行，最终a=0，那么执行的次数就是a中1的个数
- a & (~a + 1) 得到a最右边为1，其余位是0的数 即1010 -> 0010

2.选择排序：通过双层循环，找到更小的数和i位置的数进行交换
> 时间复杂度：O(n^2)
>
> ​	第一次遍历：n-1次，第一次比较：n-1 第一次交换：一次
>
> ​	第二次遍历：n-2次，第二次比较：n-2 第一次交换：一次
>
> ​	根据通项公式求和，结果是 an^2 + bn + c，所以时间复杂度就是O(n^2)
>
> 空间复杂度：O(1)
>
> 空间复杂度和n没有关系，只是常量级别的额外空间，所以是O(1)

3.冒泡排序：通过双层循环，相邻的两个数比较交换
> 时间复杂度：O(n^2)
>
> ​	第一次遍历：n-1次，第一次比较：n-1 第一次交换：一次
>
> ​	第二次遍历：n-2次，第二次比较：n-2 第一次交换：一次
>
> ​	根据通项公式求和，结果是 an^2 + bn + c，所以时间复杂度就是O(n^2)
>
> 空间复杂度：O(1)
>
> ​	空间复杂度和n没有关系，只是常量级别的额外空间，所以是O(1)

4.插入排序：依次遍历数组，当前数一直和左边的数比较，比它小的话交换，大或者没数停止
> 时间复杂度：O(n^2) 
>
> ​	[1, 5, 3, 6, 2]
>
> ​	第一次遍历：0位置和0位置比较，比较1次，不用交换
>
> ​	第二次遍历：0-1位置 比较1次，不用交换
>
> ​	第三次遍历：0-2位置  3和5比较交换，3和1比较不交换，比较2次，交换1次
>
> ​	但是存在一种情况，[1,2,3,4]数组本身就是有序的，只需比较不交换，这种时间复杂度就是O(n)，
>
> ​	最坏情况下每次[4,3,2,1]就是等差数列，时间复杂度就是O(n^2)
>
> ​	按照时间复杂度定义，取最坏的情况，插入排序时间复杂度就是O(n^2)
>
> 空间复杂度：O(1)
>
> ​	空间复杂度和n没有关系，只是常量级别的额外空间，所以是O(1)

## 四、二分法：一次砍一半 一次砍一半 砍几次 
1.时间复杂度：O(logN)
- 有序数组是否存在某个数： 底数默认2
- 有序数组找大于num最左侧的索引位置，时间复杂度：O(logN)
- 无序且数不相等数组，找任意一个局部最小值（如果0位置比1位置小，或者如果n比n-1位置数小，或者i比i-1小且比i+1小，符合任意一种就是局部最小值）

## 五、对数器
1.简单来讲，就是生成随机长度数组，随机值的数组中数，分别放入两段代码执行，最终两个数组一一比对，不对，那么两段代码可能都有问题
